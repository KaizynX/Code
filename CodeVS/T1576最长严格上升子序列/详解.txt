定义：a[1..n]为原始序列，d[k]表示长度为k的不下降子序列末尾元素的最小值，len表示当前已知的最长子序列的长度。

  初始化：d[1]=a[1]; len=1; （0个元素的时候特判一下）

  现在我们已知最长的不下降子序列长度为1，末尾元素的最小值为a[1]，那么我们让i从2到n循环，依次求出前i个元素的最长不下降子序列的长度，循环的时候我们只需要维护好d这个数组还有len就可以了。

  关键问题就是怎么维护？

  可以看出我们是要用logn的复杂度维护的。实际上利用了d数组的一个性质：单调性。（长度更长了，d[k]的值是不会减小的）

  考虑新进来一个元素a[i]：

　　如果这个元素大于等于d[len]，直接让d[len+1]=a[i]，然后len++。这个很好理解，当前最长的长度变成了len+1，而且d数组也添加了一个元素。

　　如果这个元素小于d[len]呢？说明它不能接在最后一个后面了。那我们就看一下它该接在谁后面。

　　　　准确的说，并不是接在谁后面。而是替换掉谁。因为它接在前面的谁后面都是没有意义的，再接也超不过最长的len，所以是替换掉别人。那么替换掉谁呢？就是替换掉那个最该被它替换的那个。也就是在d数组中第一个大于它的。第一个意味着前面的都小于等于它。假设第一个大于它的是d[j]，说明d[1..j-1]都小于等于它，那么它完全可以接上d[j-1]然后生成一个长度为j的不下降子序列，而且这个子序列比当前的d[j]这个子序列更有潜力（因为这个数比d[j]小）。所以就替换掉它就行了，也就是d[j]=a[i]。其实这个位置也是它唯一能够替换的位置（前面的替了不满足d[k]最小值的定义，后面替换了不满足不下降序列）

　　至于第一个大于它的怎么找……STL upper_bound。每次复杂度logn。